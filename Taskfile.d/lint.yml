---
# https://taskfile.dev

version: '3'

vars:
  IMAGE_HADOLINT: hadolint/hadolint
  # IMAGE_LYCHEE: lycheeverse/lychee:latest-alpine
  IMAGE_LYCHEE: lycheeverse/lychee:latest
  IMAGE_MARKDOWNLINT: davidanson/markdownlint-cli2
  IMAGE_SHELLCHECK: koalaman/shellcheck:stable
  IMAGE_YAMLINT: jfxs/ansible

tasks:

  all:
    desc: 'Linter for files, markdown, yaml extensions. Arguments: [FIX|F=y|Y] [MEX|M=\"#node_modules\"] (*)'
    summary: |
      [LINT] Linter for files.
      Usage: task lint:file [FIX|F=<y|Y>] [MEX|M='"#node_modules"']

      Arguments:
        FIX | F  Fix files (optional, by default no)
        MEX | M  Makdown exlude directories with single quotes example: MEX='"#node_modules" "#.node_cache"' (see: https://github.com/DavidAnson/markdownlint-cli2)

      Notes:
       - Only git versionned files are checked for generic files. Use MEX argument for Mardown files and .yamlint for YAML files.

      Requirements:
        - markdownlint-cli2 or docker
        - yamllint or docker
    vars:
      FIX: '{{default .F .FIX}}'
      MEX: '{{default .M .MEX}}'
    cmds:
      - echo "Files:" && echo "======"
      - task: file
        vars: {FIX: "{{.FIX}}"}
      - echo "" && echo "Markdown:" && echo "========="
      - task: markdown
        vars: {GLOB: '"**/*.md" {{.MEX}}'}
      - echo "" && echo "YAML:" && echo "====="
      - task: yaml
      - echo "" && echo "Lychee:" && echo "======="
      - task: lychee
    silent: true

  docker:
    desc: "Linter for Dockerfiles. Arguments: [FILE|F=Dockerfile] [IMG|I=hadolint/hadolint] [PULL|P=n|N] (*)"
    summary: |
      [LINT] Linter for Dockerfiles.
      Usage: task lint:markdown [FILE|F=Dockerfile] [IMG|I=hadolint/hadolint] [PULL|P=<n|N>]

      Arguments:
        FILE | F  Path of the Docker file to lint (optional, by default Dockerfile)
        IMG  | I  Docker markdownlint image to use (optional, by default {{.IMAGE_HADOLINT}})
        PULL | P  Pull docker image (optional, by default yes)

      Requirements:
        - hadolint or docker
    vars:
      FILE: '{{default .F .FILE}}'
      FILE_D: '{{default "Dockerfile" .FILE}}'
      IMG: '{{default .I .IMG}}'
      IMG_D: '{{default .IMAGE_HADOLINT .IMG}}'
      PULL: '{{default .P .PULL}}'
      EXEC: hadolint
    cmds:
      - |
        if (! test -n "{{.IMG}}") && (command -v {{.EXEC}} 2>&1 >/dev/null); then
          {{.EXEC}} {{.FILE_D}}
        else
          if ! command -v docker 2>&1 >/dev/null; then
            echo "docker and {{.EXEC}} are not installed!" && exit 1
          fi
          if [ "{{.PULL}}" != "n" ] && [ "{{.PULL}}" != "N" ]; then docker pull "{{.IMG_D}}"; fi
          docker run -t --rm -v $(pwd):/mnt "{{.IMG_D}}" {{.EXEC}} /mnt/{{.FILE_D}}
        fi
    silent: true

  file:
    desc: "Linter for files. Arguments: [FIX|F=y|Y] (*)"
    summary: |
      [LINT] Linter for files.
      Usage: task lint:file [FIX|F=<y|Y>]

      Arguments:
        FIX | F  Fix files (optional, by default no)

      Notes:
       - Only git versionned files are checked.
    vars:
      FIX: '{{default .F .FIX}}'
    cmds:
      - task: file-utf8
      - task: file-cr
        vars: {FIX: "{{.FIX}}"}
      - task: file-tws
        vars: {FIX: "{{.FIX}}"}
      - task: file-nleof
    silent: true

  file-cr:
    # desc: "Linter CR (Carriage Return). Arguments: [FIX|F=y|Y] (*)"
    # summary: |
    #   [LINT] Linter CR (Carriage Return).
    #   Usage: task lint:file-cr [FIX|F=<y|Y>]
    #
    #   Arguments:
    #     FIX | F  Fix files (optional, by default no)
    #
    #   Notes:
    #    - Only git tracked files are checked,
    #    - add "# Exclude" to lines you want to exclude from lint.
    vars:
      FIX: '{{default .F .FIX}}'
      GREP_RE: "\r"  # Exclude
      SED_RE: "\r"  # Exclude
      DESC: "CR (Carriage Return)"
    cmds:
      - task: find-remove
        vars: {GREP: "{{.GREP_RE}}", SED: "{{.SED_RE}}", DESC: "{{.DESC}}", FIX: "{{.FIX}}"}
    silent: true

  file-nleof:
    # desc: "Linter for one new line at the end of a file. Arguments: [FIX|F=y|Y] (*)"
    # summary: |
    #   [LINT] Linter for one new line at the end of a file.
    #   Usage: task lint:file-nleof [FIX|F=<y|Y>]
    #
    #   Arguments:
    #     FIX | F  Fix files (optional, by default no)
    #
    #   Notes:
    #    - Only git tracked files are checked.
    cmds:
      - git ls-files > ls-files.tmp
      - defer: rm -f ls-files.tmp
      - |
        count_all=0
        count_ko=0
        while read -r line
        do
          # File exists in local
          if [ -e "$line" ]; then
            format=$(file -b --mime-encoding "$line")
            is_binary=$(echo "$format" | grep -c binary || true)
            # If text file
            if [ "$is_binary" = "0" ]; then
              count_all=$((count_all+1))
              # Get 2 last char | no adresse, write all input data, specify output format
              end_file=$(tail -c 2 "$line" | od -An -v -tc)
              char1=$(echo "$end_file" | awk '{print $1}')
              char2=$(echo "$end_file" | awk '{print $2}')
              if [ "$char2" = "\n" ]; then
                if [ "$char1" = "\n" ]; then
                printf "%s has more than one newline at the end of the file!\n" "$line"
                count_ko=$((count_ko+1))
                fi
              else
                printf "%s has no newline at the end of the file!\n" "$line"
                count_ko=$((count_ko+1))
              fi
            fi
          fi
        done < ls-files.tmp
        if [ "$count_ko" = "0" ]; then
            printf "\033[0;32m[OK] All %s text files have an empty line at the end of file.\033[0m\n" "$count_all"
        else
          printf "\033[0;31m[KO] %s text files have not exactly one empty line at the end of file!\033[0m\n" "$count_ko"
        fi
        exit "$count_ko"
    silent: true

  file-tws:
    # desc: "Linter for trailing whitespaces at the end of a line. Arguments: [FIX|F=y|Y] (*)"
    # summary: |
    #   [LINT] Linter trailing whitespace line at the end of a line.
    #   Usage: task lint:file-tws [FIX|F=<y|Y>]
    #
    #   Arguments:
    #     FIX | F  Fix files (optional, by default no)
    #
    #   Notes:
    #    - Only git tracked files are checked,
    #    - add "# Exclude" to lines you want to exclude from lint.
    vars:
      FIX: '{{default .F .FIX}}'
      GREP_RE: "[[:space:]]$"  # Exclude
      SED_RE: "[[:space:]]*$"  # Exclude
      DESC: "trailing whitespaces at the end of line(s)"
    cmds:
      - task: find-remove
        vars: {GREP: "{{.GREP_RE}}", SED: "{{.SED_RE}}", DESC: "{{.DESC}}", FIX: "{{.FIX}}"}
    silent: true

  file-utf8:
    # desc: "Check if text files are utf-8 encoded. (*)"
    # summary: |
    #   [LINT] Check if text files are utf-8 encoded.
    #   Usage: task lint:file-utf8
    #
    #   Notes:
    #    - Only git tracked files are checked.
    cmds:
      - git ls-files > ls-files.tmp
      - defer: rm -f ls-files.tmp
      - |
        count_all=0
        count_ko=0
        while read -r line; do
          # File exists in local
          if [ -e "$line" ]; then
            format=$(file -b --mime-encoding "$line")
            is_binary=$(echo "$format" | grep -c binary || true)
            # If text file
            if [ "$is_binary" = "0" ]; then
              count_all=$((count_all+1))
              if ! iconv -f utf8 -t utf8 < "$line" >/dev/null 2>&1; then
                printf "%s is not in UTF-8 format, probably %s!\n" "$line" "$format"
                count_ko=$((count_ko+1))
              fi
            fi
          fi
        done < ls-files.tmp
        if [ "$count_ko" = "0" ]; then
            printf "\033[0;32m[OK] All %s text files are UTF-8 encoded.\033[0m\n" "$count_all"
        else
          printf "\033[0;31m[KO] %s text files are not in UTF-8 format!\033[0m\n" "$count_ko"
        fi
        exit "$count_ko"
    preconditions:
      - sh: command -v git
        msg: "git is not installed"
    silent: true

  lychee:
    desc: "Find broken hyperlinks with lychee. Arguments: [ARGS|A='.'] [IMG|I=lycheeverse/lychee] [PULL|P=n|N] (*)"
    summary: |
      [LINT] Find broken hyperlinks.
      Usage: task lint:lychee [ARGS|A='.'] [IMG|I=lycheeverse/lychee] [PULL|P=<n|N>]

      Arguments:
        ARGS | A  Glob expressions (optional, by default ".")
        IMG  | I  Docker markdownlint image to use (optional, by default {{.IMAGE_LYCHEE}})
        PULL | P  Pull docker image (optional, by default yes)

      Notes:
       - To exclude directories create a lychee.toml file with the exclude_path = ["dir1", "dir2"] directive
       - Documentation: https://github.com/lycheeverse/lychee

      Requirements:
        - lychee or docker
    vars:
      ARGS: '{{default .A .ARGS}}'
      ARGS_D: '{{default "." .ARGS}}'
      IMG: '{{default .I .IMG}}'
      IMG_D: '{{default .IMAGE_LYCHEE .IMG}}'
      PULL: '{{default .P .PULL}}'
      EXEC: lychee
    cmds:
      - |
        if (! test -n "{{.IMG}}") && (command -v {{.EXEC}} 2>&1 >/dev/null); then
          {{.EXEC}} {{.ARGS_D}}
        else
          if ! command -v docker 2>&1 >/dev/null; then
            echo "docker and {{.EXEC}} are not installed!" && exit 1
          fi
          if [ "{{.PULL}}" != "n" ] && [ "{{.PULL}}" != "N" ]; then docker pull "{{.IMG_D}}"; fi
          docker run -t --rm -w /input -v $(pwd):/input "{{.IMG_D}}" {{.ARGS_D}}
        fi
    silent: true

  markdown:
    desc: "Linter for Mardown files. Arguments: [GLOB|G='\"**/*.md\"'] [IMG|I=tmknom/markdownlint] [PULL|P=n|N] (*)"
    summary: |
      [LINT] Linter for Markdown files.
      Usage: task lint:markdown [GLOB|G='"**/*.md" "#node_modules"'] [IMG|I=tmknom/markdownlint] [PULL|P=<n|N>]

      Arguments:
        GLOB | G  Glob expressions (optional, by default "**/*.md")
        IMG  | I  Docker markdownlint image to use (optional, by default {{.IMAGE_MARKDOWNLINT}})
        PULL | P  Pull docker image (optional, by default yes)

      Notes:
       - Documentation of Glob expressions: https://github.com/DavidAnson/markdownlint-cli2

      Requirements:
        - markdownlint-cli2 or docker
    vars:
      GLOB: '{{default .G .GLOB}}'
      GLOB_D: '{{default "\"**/*.md\"" .GLOB}}'
      IMG: '{{default .I .IMG}}'
      IMG_D: '{{default .IMAGE_MARKDOWNLINT .IMG}}'
      PULL: '{{default .P .PULL}}'
      EXEC: markdownlint-cli2
    cmds:
      - |
        if (! test -n "{{.IMG}}") && (command -v {{.EXEC}} 2>&1 >/dev/null); then
          {{.EXEC}} {{.GLOB_D}}
        else
          if ! command -v docker 2>&1 >/dev/null; then
            echo "docker and {{.EXEC}} are not installed!" && exit 1
          fi
          if [ "{{.PULL}}" != "n" ] && [ "{{.PULL}}" != "N" ]; then docker pull "{{.IMG_D}}"; fi
          docker run -t --rm -v $(pwd):/workdir "{{.IMG_D}}" {{.GLOB_D}}
        fi
    silent: true

  shell:
    desc: "Linter for bash/sh shell files. Arguments: FILES|F=\"myscripts/*.sh\" [IMG|I=koalaman/shellcheck:stable] [PULL|P=n|N] (*)"
    summary: |
      [LINT] Linter for bash/sh shell files.
      If shellcheck command is in the path and IMG/I argument is not set, the local shellcheck command is executed,
      otherwise a shellcheck Docker image is used.
      Usage: task lint:shell FILES|F="myscripts/*.sh" [IMG|I=<koalaman/shellcheck:stable>] [PULL|P=<n|N>]

      Arguments:
        FILES | F  Files to check (required)
        IMG   | I  Docker shellcheck image to use (optional, by default {{.IMAGE_SHELLCHECK}})
        PULL  | P  Pull docker image (optional, by default yes)

      Requirements:
        - shellcheck or docker
    vars:
      FILES: '{{default .F .FILES}}'
      IMG: '{{default .I .IMG}}'
      IMG_D: '{{default .IMAGE_SHELLCHECK .IMG}}'
      PULL: '{{default .P .PULL}}'
      EXEC: shellcheck
    cmds:
      - |
        if (! test -n "{{.IMG}}") && (command -v {{.EXEC}} 2>&1 >/dev/null); then
          {{.EXEC}} {{.FILES}}
        else
          if ! command -v docker 2>&1 >/dev/null; then
            echo "docker and {{.EXEC}} are not installed!" && exit 1
          fi
          if [ "{{.PULL}}" != "n" ] && [ "{{.PULL}}" != "N" ]; then docker pull "{{.IMG_D}}"; fi
          docker run -t --rm -v $(pwd):/mnt "{{.IMG_D}}" {{.FILES}}
        fi
    preconditions:
      - sh: test -n "{{.FILES}}" || test -n "{{.F}}"
        msg: "FILES|F argument is required"
    silent: true

  yaml:
    desc: "Linter for YAML files. Arguments: [FILES|F=\".\"] [IMG|I=jfxs/ansible] [PULL|P=n|N] (*)"
    summary: |
      [LINT] Linter for YAML files.
      If yamllint command is in the path and IMG/I argument is not set, the local yamllint command is executed,
      otherwise a yamllint Docker image is used.
      You can configure rules and exclude directories with a .yamlint configuration file:
      https://yamllint.readthedocs.io/en/stable/configuration.html
      Usage: task lint:yaml [PULL|P=<n|N>]

      Arguments:
        FILES | F  Files to check (optional, by default .)
        IMG   | I  Docker yamllint image to use (optional, by default {{.IMAGE_YAMLINT}})
        PULL  | P  Pull docker image (optional, by default yes)

      Requirements:
        - yamllint or docker
    vars:
      FILES: '{{default .F .FILES}}'
      FILES_D: '{{default "." .FILES}}'
      IMG: '{{default .I .IMG}}'
      IMG_D: '{{default .IMAGE_YAMLINT .IMG}}'
      PULL: '{{default .P .PULL}}'
      EXEC: yamllint
    cmds:
      - |
        if (! test -n "{{.IMG}}") && (command -v {{.EXEC}} 2>&1 >/dev/null); then
          {{.EXEC}} {{.FILES_D}}
        else
          if ! command -v docker 2>&1 >/dev/null; then
            echo "docker and {{.EXEC}} are not installed!" && exit 1
          fi
          if [ "{{.PULL}}" != "n" ] && [ "{{.PULL}}" != "N" ]; then docker pull "{{.IMG_D}}"; fi
          docker run -t --rm -v $(pwd):/ansible "{{.IMG_D}}" {{.EXEC}} {{.FILES_D}}
        fi
    silent: true

  find-remove:
    vars:
      EXCLUDE_PATTERN: "# Exclude"
      FILE_FR: "{{.TASK}}.tmp"
    cmds:
      - git grep -nIE "$(printf '{{.GREP}}')" | grep -v "{{.EXCLUDE_PATTERN}}" > {{.FILE_FR}} || true
      - defer: rm -f {{.FILE_FR}}
      - |
        count=$(wc -l < {{.FILE_FR}} | awk '{print $1}')
        if [ "$count" = "0" ]; then
          printf "\033[0;32m[OK] No file with %s found.\033[0m\n" "{{.DESC}}"
        else
          printf "\033[0;31m[KO] %s %s found:\033[0m\n" "$count" "{{.DESC}}"
          if [ "{{.FIX}}" = "y" ] || [ "{{.FIX}}" = "Y" ]; then
            files=""
            while read -r line; do
              # Get file name only
              file=$(printf "%s" "$line" | sed -E 's/:[0-9]+:.*//')
              # Set list with EOL separator
              if [ -z "$files" ]; then
                files="$file"
              else
                files=$(printf "%s\n%s" "$files" "$file")
              fi
            done < {{.FILE_FR}}
            # Remove duplicate filename
            uniq_files=$(printf "%s" "$files" | uniq)
            printf "%s" "$uniq_files" | while read -r line ; do
              sed -i.bu -E '/.*{{.EXCLUDE_PATTERN}}.*/!s/{{.SED}}//' "$line"
              rm -f "$line.bu"
              printf "\033[0;32mFile %s fixed\033[0m\n" "$line"
            done
          else
            cat {{.FILE_FR}}
          fi
        fi
        exit "$count"
    preconditions:
      - sh: command -v git
        msg: "git is not installed"
      - sh: test -n "{{.GREP}}"
        msg: "GREP argument is required"
      - sh: test -n "{{.SED}}"
        msg: "SED argument is required"
      - sh: test -n "{{.DESC}}"
        msg: "DESC argument is required"
    silent: true
